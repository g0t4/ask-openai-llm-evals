{"model":"qwen2.5-coder:7b-base-q8_0","options":{"num_ctx":8192},"prompt":"<|repo_name|>ask-openai.nvim\n<|file_sep|>nvim-recent-yanks.txt\n## Recent yanks across all files in the project:\nfunction(tag)\n            return tag.file_name\n        end\n\n<|file_sep|>tags\nlua/ask-openai/rewrites/BufferController.lua\n    function BufferController0Indexed:file_name()<|file_sep|>.ask.context\nDon't forget, any time you see a file path, in lua code... you can turn that into a require call... for example:\nlua/ask-openai/foo/bar.lua => require(\"ask-openai.foo.bar\")\n\n\n<|file_sep|>lua/ask-openai/prediction/context/ctags.lua\n<|fim_prefix|>local super_iter = require(\"devtools.super_iter\")\nlocal messages = require(\"devtools.messages\")\nlocal files = require(\"ask-openai.helpers.files\")\n\nlocal M = {}\n\n---@return string file_path\nfunction M.find_tags_file_for_this_workspace()\n    return \"tags\"\n    -- local result = vim.fn.findfile(\"tags\", vim.fn.getcwd() .. \";\")\nend\n\n---@alias ParsedTagLine { tag_name: string, file_name: string, ex_command : string }\n\n---@param lines string[]\n---@param language string\n---@return ParsedTagLine[]\nfunction M.parse_tag_lines(lines, language)\n    return vim.iter(lines)\n        -- filter on raw lines\n        :filter(function(line)\n            return not line:match(\"^[#!]\")\n                and not line:match(\"%.tests%.\")\n        end)\n        -- split her up!\n        :map(function(line)\n            local splits = vim.split(line, \"\\t\", { plain = true, n = 2 })\n            return {\n                tag_name = splits[1],\n                file_name = splits[2],\n                ex_command = splits[3]:gsub(';\"$', \"\")\n            }\n        end)\n        -- filter on fields\n        :filter(function(tag)\n            return not tag.ex_command:match(\"/^%s*local\")\n                and tag.file_name:match(\".\" .. language .. \"$\")\n        end)\n        :totable()\nend\n\n---@param parsed_tag_lines ParsedTagLine[]\n---@return string\nfunction M.reassemble_tags(parsed_tag_lines, file_name_func)\n    file_name<|fim_suffix|>\n\n    return super_iter(parsed_tag_lines)\n        :group_by(file_name_func)\n        :map(function(key, items)\n            local lines = { key }\n            for _, tag in ipairs(items) do\n                -- FYI stripping /^ $/ removed 19% of tokens in a test run\n                -- also strip leading spaces... not sure it would be useful anyways (did not analyze savings from that)\n                local stripped_ex_command = tag.ex_command\n                    :gsub(\"/^%s*\", \"\")\n                    :gsub(\"$/\", \"\")\n                table.insert(lines, \"    \" .. stripped_ex_command)\n            end\n            return table.concat(lines, \"\\n\")\n        end)\n        :join(\"\\n\")\nend\n\n---@param file_path string\n---@param language string\n---@return ParsedTagLine[]\nfunction M.get_parsed_tag_lines(file_path, language)\n    return M.parse_tag_lines(files.read_file_lines(file_path), language)\nend\n\n---@param file_path string\n---@param language string\n---@return string tags_reassembled\nfunction M.get_reassembled_text(file_path, language)\n    return M.reassemble_tags(M.get_parsed_tag_lines(file_path, language))\nend\n\n---@return string file_path\nfunction M.find_devtools_tags_file()\n    return os.getenv(\"HOME\") .. \"/repos/github/g0t4/devtools.nvim/tags\"\nend\n\n-- * reassembled entrypoints:\n---@return string\nfunction M.reassembled_tags_for_lua_devtools()\n    return M.get_reassembled_text(\n        M.find_devtools_tags_file(),\n        \"lua\"\n    )\nend\n\n---@return string\nfunction M.reassembled_tags_for_this_workspace(language)\n    local tags = M.find_tags_file_for_this_workspace()\n    return M.get_reassembled_text(tags, language)\nend\n\n-- TODO fix ctags context to use this new all_reassembled_tags method\n---@return string[]\nfunction M.all_reassembled_tags()\n    local language = M.get_language_for_current_buffer()\n    local reassembeds = {\n        -- todo more than one lib prompts!\n        M.reassembled_tags_for_this_workspace(language),\n    }\n    if language == \"lua\" then\n        table.insert(reassembeds, M.reassembled_tags_for_lua_devtools())\n    end\n    return reassembeds\nend\n\n-- * parsed_tag_lines (only) entrypoints:\n---@return ParsedTagLine[]\nfunction M.parsed_tag_lines_for_lua_devtools()\n    return M.parse_tag_lines(files.read_file_lines(M.find_devtools_tags_file()), \"lua\")\nend\n\n---@return ParsedTagLine[]\nfunction M.parsed_tag_lines_for_this_workspace(language)\n    return M.parse_tag_lines(files.read_file_lines(M.find_tags_file_for_this_workspace()), language)\nend\n\nfunction M.get_language_for_current_buffer()\n    -- PRN can add logic to map here\n    return vim.bo.filetype\nend\n\nfunction M.dump_this()\n    -- get current file's type\n    local language = M.get_language_for_current_buffer()\n\n    messages.header(\"Parsed lines for `\" .. language .. \"`\")\n    messages.ensure_open()\n    messages.append(M.reassembled_tags_for_this_workspace(language))\n    messages.scroll_back_before_last_append()\nend\n\nfunction M.setup()\n    vim.api.nvim_create_user_command(\"AskDumpCTags\", M.dump_this, {})\nend\n\nreturn M<|fim_middle|>","stream":true,"raw":true,"num_predict":200}